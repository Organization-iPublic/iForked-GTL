#-----------------------------------------------------------------------------*
#
#  @file gtl_debugger_parser.galgas
#
#  @section desc File description
#
#  Debugger parser for GTL.
#
#  @section copyright Copyright
#
#  GTL template language, part of Trampoline RTOS
#
#  Trampoline is copyright (c) CNRS, University of Nantes,
#  Ecole Centrale de Nantes
#  Trampoline is protected by the French intellectual property law.
#
#  This software is distributed under the GNU Public Licence V2.
#  Check the LICENSE file in the root directory of Trampoline
#
#  $Date$
#  $Rev$
#  $Author$
#  $URL$
#
#-----------------------------------------------------------------------------*

syntax gtl_debugger_parser (gtl_scanner) {

#-----------------------------------------------------------------------------*
rule <gtl_expression>
  !@gtlExpression expression

rule <gtl_variable>
  !@gtlVarPath path

#-----------------------------------------------------------------------------*
rule <gtl_debugger_command>
  !@gtlInstruction instruction
{
  $identifier$ ?let @lstring command
  if "c" == command | "cont" == command | "continue" == command then
    instruction = @gtlContinueInstruction.new {
      !.here
      !""
    }
  elsif "help" == command then
    instruction = @gtlHelpInstruction.new {
      !.here
      !""
    }    
  else
    error .here : "Illegal command: " + command : instruction
  end
}

#-----------------------------------------------------------------------------*
rule <gtl_debugger_command>
  !@gtlInstruction instruction
{
  $step$
  instruction = @gtlStepInstruction.new {
    !.here
    !""
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_debugger_command>
  !@gtlInstruction instruction
{
  $break$
  select
    $not$
    $signed_literal_integer_bigint$ ?let @lbigint index
    instruction = @gtlBreakpointDeleteInstruction.new {
      !.here
      !""
      !index
    }
  or
    select 
      $identifier$ ?let @lstring fileName
      $.$
      $identifier$ ?let @lstring fileExtension
      $:$
      $signed_literal_integer_bigint$ ?let @lbigint lineNum
      instruction = @gtlBreakpointInstruction.new {
        !.here
        !""
        ![fileName string] + "." + fileExtension
        ![lineNum bigint]
      }
    or
      $signed_literal_integer_bigint$ ?let @lbigint lineNum
      instruction = @gtlBreakpointInstruction.new {
        !.here
        !""
        !""
        ![lineNum bigint]
      }
    end
  or
    $string$ ?let @lstring fileNameAndLineNum
    @stringlist components = [[fileNameAndLineNum string] componentsSeparatedByString !":"]
    if [components length] == 2 then
      @string fileName = [components mValueAtIndex !0]
      @string lineNum = [components mValueAtIndex !1]
      instruction = @gtlBreakpointInstruction.new {
        !.here
        !""
        !fileName
        ![lineNum decimalUnsignedNumber]
      }
    else
      error .here : "Illegal breakpoint location" : instruction
    end
  or
    instruction = @gtlBreakpointListInstruction.new {
      !.here
      !""
    }
  end  
}

#-----------------------------------------------------------------------------*
rule <gtl_debugger_command>
  !@gtlInstruction instruction
{
  
  $do$
  select
    <gtl_step_do_command> ?@gtlInstruction instructionToStepDo
    instruction = @gtlDoInstInstruction.new {
      !.here
      !""
      !instructionToStepDo
    }
  or
    $not$
    $signed_literal_integer_bigint$ ?let @lbigint num
    instruction = @gtlDoNotInstruction.new {
      !.here
      !""
      !num
    }
  or
    instruction = @gtlDoInstruction.new {
      !.here
      !""
    }    
  end
}

#-----------------------------------------------------------------------------*
rule <gtl_debugger_command>
  !@gtlInstruction instruction
{
  instruction = @gtlStepInstruction.new {
    !.here
    !""
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_debugger_command>
  !@gtlInstruction instruction
{
  $let$
  <gtl_variable> ?@gtlVarPath variable
  select
    $:=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetInstruction.new { 
      !.here
      !""
      !variable
      !expression
    } 
  or
    $+=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetAddInstruction.new {
      !.here
      !""
      !variable
      !expression
    } 
  or
    $-=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetSubstractInstruction.new {
      !.here
      !""
      !variable
      !expression
    } 
  or
    $*=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetMultiplyInstruction.new {
      !.here
      !""
      !variable
      !expression
    } 
  or
    $/=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetDivideInstruction.new {
      !.here
      !""
      !variable
      !expression
    } 
  or
    $mod=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetModuloInstruction.new {
      !.here
      !""
      !variable
      !expression
    } 
  or
    $<<=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetShiftLeftInstruction.new {
      !.here
      !""
      !variable
      !expression
    } 
  or
    $>>=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetShiftRightInstruction.new {
      !.here
      !""
      !variable
      !expression
    } 
  or
    $&=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetAndInstruction.new {
      !.here
      !""
      !variable
      !expression
    } 
  or
    $|=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetOrInstruction.new {
      !.here
      !""
      !variable
      !expression
    } 
  or
    $^=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetXorInstruction.new {
      !.here
      !""
      !variable
      !expression
    }
  or
    instruction = @gtlLetUnconstructedInstruction.new {
      !.here
      !""
      !variable
    }
  end
}

#-----------------------------------------------------------------------------*
rule <gtl_debugger_command>
  !@gtlInstruction instruction
{
  $unlet$
  <gtl_variable> ?@gtlVarPath variable
  instruction = @gtlUnletInstruction.new {
    !.here
    !""
    !variable
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_debugger_command>
  !@gtlInstruction instruction
{
  <gtl_step_do_command> ?instruction
}

#-----------------------------------------------------------------------------*
rule <gtl_step_do_command>
  !@gtlInstruction instruction
{
  $variables$
  instruction = @gtlVariablesInstruction.new {
    !.here
    !""
    !true
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_step_do_command>
  !@gtlInstruction instruction
{
  $display$
  <gtl_variable> ?@gtlVarPath variable  
  instruction = @gtlDisplayStatementInstruction.new {
    !.here
    !""
    !variable
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_step_do_command>
  !@gtlInstruction instruction
{
  $print$ 
  <gtl_expression> ?@gtlExpression expression
  instruction = @gtlPrintStatementInstruction.new {
    !.here
    !""
    !true
    !expression
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_step_do_command>
  !@gtlInstruction instruction
{
  $here$
  instruction = @gtlHereInstruction.new {
    !.here
    !""
  }
}

}
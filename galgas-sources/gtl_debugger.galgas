#-----------------------------------------------------------------------------*
#
#  @file gtl_debugger.galgas
#
#  @section desc File description
#
#  Debugger for GTL.
#
#  @section copyright Copyright
#
#  GTL template language, part of Trampoline RTOS
#
#  Trampoline is copyright (c) CNRS, University of Nantes,
#  Ecole Centrale de Nantes
#  Trampoline is protected by the French intellectual property law.
#
#  This software is distributed under the GNU Public Licence V2.
#  Check the LICENSE file in the root directory of Trampoline
#
#  $Date$
#  $Rev$
#  $Author$
#  $URL$
#
#-----------------------------------------------------------------------------*

func signature
  ?@location loc
  ->@string result
{
  if [option gtl_options.debug value] then
    @string signatureString =
      [[loc file] lastPathComponent]
      + ":"
      + [loc line]
#      message signatureString + "\n"
    result = [signatureString md5]
  else
    result = ""
  end
}

#=============================================================================*
# @@debuggerContext is used to store the debugging context
#-----------------------------------------------------------------------------*
class @debuggerContext
{
  @bool debugActive %setter
  @bool breakOnNext %setter
}

#-----------------------------------------------------------------------------*
func defaultDebugSettings
  ->@debuggerContext debugSettings
{
  debugSettings = .new { !false !false }
}

#-----------------------------------------------------------------------------*
setter @gtlContext setDebugger
  ?@bool debugOn
{
  [!?debuggerContext setDebugActive !debugOn]
}

#-----------------------------------------------------------------------------*
setter @gtlContext setBreakOnNext
{
  [!?debuggerContext setBreakOnNext !true]
}

#-----------------------------------------------------------------------------*
getter @gtlContext debugActive
  ->@bool debugOn
{
  debugOn = [debuggerContext debugActive]
}

#-----------------------------------------------------------------------------*
getter @gtlContext breakOnNext
  ->@bool breakOnNext
{
  breakOnNext = [debuggerContext breakOnNext]
}

#=============================================================================*
getter @gtlVarPath stringRepresentation
  ->@string result
{
  result = [[self itemAtIndex !0] stringRepresentation !""]
  for (item) in [self subListFromIndex !1] do
    result += [item stringRepresentation !"::"]
  end
}

#-----------------------------------------------------------------------------*
abstract getter @gtlVarItem stringRepresentation
  ?let @string concatString
  ->@string

#-----------------------------------------------------------------------------*
override getter @gtlVarItemField stringRepresentation
  ?let @string concatString
  ->@string result
{
  result = concatString + field
}

#-----------------------------------------------------------------------------*
override getter @gtlVarItemSubCollection stringRepresentation
  ?let @string unused concatString
  ->@string result
{
  result = "[" + [key stringRepresentation] + "]"
}

#-----------------------------------------------------------------------------*
override getter @gtlVarItemCollection stringRepresentation
  ?let @string concatString
  ->@string result
{
  result = concatString + field + '[' + [key stringRepresentation] + ']'
}

#=============================================================================*
abstract getter @gtlExpression stringRepresentation
  ->@string

#-----------------------------------------------------------------------------*
override getter @gtlAddExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " + " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlAndExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " & " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlDivideExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " / " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlEqualExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " == " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlGreaterOrEqualExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " >= " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlGreaterThanExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " > " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlLowerOrEqualExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " <= " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlLowerThanExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " < " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlModulusExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " mod " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlMultiplyExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " * " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlNotEqualExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " != " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlOrExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " | " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlShiftLeftExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " << " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlShiftRightExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " >> " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlSubstractExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " - " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlXorExpression stringRepresentation
  ->@string result
{
  result = [lSon stringRepresentation] + " ^ " + [rSon stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlExistsExpression stringRepresentation
  ->@string result
{
  result = "exists " + [variable stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlFunctionCallExpression stringRepresentation
  ->@string result
{
  result = [functionName string] + "(" + [functionArguments stringRepresentation] + ")"
}

#-----------------------------------------------------------------------------*
override getter @gtlGetterCallExpression stringRepresentation
  ->@string result
{
  result = "[" + [target stringRepresentation] + " " + getterName
  if [arguments length] > 0 then
    result = result + ": " + [arguments stringRepresentation]    
  end
  result = result + "]"
}

#-----------------------------------------------------------------------------*
override getter @gtlListOfExpression stringRepresentation
  ->@string result
{
  result = "listof " + [expression stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlLiteralListExpression stringRepresentation
  ->@string result
{
  result = "@( " + [value stringRepresentation] + " )"
}

#-----------------------------------------------------------------------------*
override getter @gtlLiteralMapExpression stringRepresentation
  ->@string result
{
  result = "@[ " + [value mapRepresentation] + " ]"
}
  
#-----------------------------------------------------------------------------*
override getter @gtlLiteralSetExpression stringRepresentation
  ->@string result
{
  result = "@! " + [value stringRepresentation] + " !"
}
  
#-----------------------------------------------------------------------------*
override getter @gtlLiteralStructExpression stringRepresentation
  ->@string result
{
  result = "@{ " + [value structRepresentation] + " }"
}
  
#-----------------------------------------------------------------------------*
override getter @gtlMapOfStructExpression stringRepresentation
  ->@string result
{
  result = "mapof " + [expression stringRepresentation] + " end"
}
  
#-----------------------------------------------------------------------------*
override getter @gtlTerminal stringRepresentation
  ->@string result
{
  result = [value stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlTypeOfExpression stringRepresentation
  ->@string result
{
  result = "typeof " + [variable stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlMinusExpression stringRepresentation
  ->@string result
{
  result = "-" + [son stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlNotExpression stringRepresentation
  ->@string result
{
  result = "not " + [son stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlParenthesizedExpression stringRepresentation
  ->@string result
{
  result = "(" + [son stringRepresentation] + ")"
}

#-----------------------------------------------------------------------------*
override getter @gtlPlusExpression stringRepresentation
  ->@string result
{
  result = "+" + [son stringRepresentation]
}

#-----------------------------------------------------------------------------*
override getter @gtlVarRef stringRepresentation
  ->@string result
{
  result = [variableName stringRepresentation]
}

#=============================================================================*
abstract getter @gtlData stringRepresentation
  ->@string
  
#-----------------------------------------------------------------------------*
override getter @gtlBool stringRepresentation
  ->@string result
{
  result = [self string]
}
  
#-----------------------------------------------------------------------------*
override getter @gtlChar stringRepresentation
  ->@string result
{
  result = [self string]
}

#-----------------------------------------------------------------------------*
override getter @gtlEnum stringRepresentation
  ->@string result
{
  result = "$" + [self string]
}
  
#-----------------------------------------------------------------------------*
override getter @gtlFloat stringRepresentation
  ->@string result
{
  result = [self string]
}
  
#-----------------------------------------------------------------------------*
override getter @gtlInt stringRepresentation
  ->@string result
{
  result = [self string]
}
  
#-----------------------------------------------------------------------------*
override getter @gtlString stringRepresentation
  ->@string result
{
  @string literalString = [self string]
  literalString = [literalString stringByReplacingStringByString !"\n" !"\\n"] 
  literalString = [literalString stringByReplacingStringByString !"\t" !"\\t"] 
  literalString = [literalString stringByReplacingStringByString !"\f" !"\\f"] 
  literalString = [literalString stringByReplacingStringByString !"\r" !"\\r"] 
  literalString = [literalString stringByReplacingStringByString !"\v" !"\\v"] 
  literalString = [literalString stringByReplacingStringByString !"\\" !"\\\\"] 
  literalString = [literalString stringByReplacingStringByString !"\"" !"\\\""] 
  result = "\"" + literalString + "\""
}
  
#-----------------------------------------------------------------------------*
override getter @gtlUnconstructed stringRepresentation
  ->@string result
{
  result = "*UNCONSTRUCTED*"
}
  
#-----------------------------------------------------------------------------*
override getter @gtlType stringRepresentation
  ->@string result
{
  result = "@" + [self string]
}
  
#-----------------------------------------------------------------------------*
override getter @gtlList stringRepresentation
  ->@string result
{
  result = "@( "
  for (item) in value do
    result = result + [item stringRepresentation]
  between
    result = result + ", "
  end
  result = result + " )"
}

#-----------------------------------------------------------------------------*
override getter @gtlMap stringRepresentation
  ->@string result
{
  result = "@[ "
  for (key item) in value do
    result = result + "\"" + key + "\": " + [item stringRepresentation]
  between
    result = result + ", "
  end
  result = result + " ]"
}
  
#-----------------------------------------------------------------------------*
override getter @gtlStruct stringRepresentation
  ->@string result
{
  result = "@{ "
  for (key item) in value do
    result = result + key + ": " + [item stringRepresentation]
  between
    result = result + ", "
  end
  result = result + " }"
}
  
#-----------------------------------------------------------------------------*
override getter @gtlSet stringRepresentation
  ->@string result
{
  result = "@! "
  for (item) in value do
    result = result + item
  between
    result = result + ", "
  end
  result = result + " !"
}
  
#=============================================================================*
getter @gtlExpressionList stringRepresentation
  ->@string result
{
  result = ""
  for (expression) in self do
    result = result + [expression stringRepresentation]
  between
    result = result + ", "
  end
}

#=============================================================================*
getter @gtlExpressionMap mapRepresentation
  ->@string result
{
  result = ""
  for (key expression) in self do
    result = result + "\"" + key + "\": " + [expression stringRepresentation]
  between
    result = result + ", "
  end
}

#-----------------------------------------------------------------------------*
getter @gtlExpressionMap structRepresentation
  ->@string result
{
  result = ""
  for (key expression) in self do
    result = result + key + ": " + [expression stringRepresentation]
  between
    result = result + ", "
  end
}

#=============================================================================*
getter @gtlArgumentList stringRepresentation
  ->@string result
{
  result = ""
  for (typed type name) in self do
    result = result + name
    if typed then
      result = result + " : @" + [type typeName]
    end  
  between
    result = result + ", "
  end
}

#=============================================================================*
getter @lsint stringRepresentation
  ->@string result
{
  result = if 0S < self then "<" else ">" end
}

#=============================================================================*
getter @sortingKeyList stringRepresentation
  ->@string result
{
  result = ""
  for (key order) in self do
    result = result + key + " " + [order stringRepresentation]
  between
    result = ", "
  end
}

#=============================================================================*
getter @gtlInstruction shortLocation
  ->@string result
{
  result = [[where file] lastPathComponent] + ":" + [where line]
}

#-----------------------------------------------------------------------------*
method @gtlInstruction displayWithLocation
{
  message [self shortLocation] + " > "
  message "\u001B[94m\u001B[1m"
  [self display]
  message "\u001B[0m\n"
}

#=============================================================================*
method @gtlInstruction display
{
  message "[Display not available]"
}

#-----------------------------------------------------------------------------*
override method @gtlLetUnconstructedInstruction display
{
  message "let " + [lValue stringRepresentation]
}

#-----------------------------------------------------------------------------*
override method @gtlLetInstruction display
{
  message "let "
    + [lValue stringRepresentation]
    + " := "
    + [rValue stringRepresentation]
}

#-----------------------------------------------------------------------------*
override method @gtlLoopStatementInstruction display
{
  message "loop "
    + identifier
    + " from "
    + [start stringRepresentation]
    + if upDown == -1S then " down" else "" end
    + " to "
    + [stop stringRepresentation]
    + " step "
    + [step stringRepresentation]
    + " do"
}

#-----------------------------------------------------------------------------*
override method @gtlWarningStatementInstruction display
{
  message "warning "
    + if hereInstead then "here" else [identifier stringRepresentation] end
    + " : "
    + [warningMessage stringRepresentation]
}

#-----------------------------------------------------------------------------*
override method @gtlDisplayStatementInstruction display
{
  message "display " + [variablePath stringRepresentation]
}

#-----------------------------------------------------------------------------*
override method @gtlPrintStatementInstruction display
{
  message "print"
    + if carriageReturn then "ln " else " " end
    + [messageToPrint stringRepresentation]
}

#-----------------------------------------------------------------------------*
override method @gtlTemplateStringInstruction display
{
  message "%" + value + "%"
}

#-----------------------------------------------------------------------------*
override method @gtlInputStatementInstruction display
{
  message "input ( " + [formalArguments stringRepresentation] + " )"
}

#-----------------------------------------------------------------------------*
override method @gtlSortStatementInstruction display
{
  message "sort "
    + [variablePath stringRepresentation] 
    + " " 
    + [order stringRepresentation]
}

#-----------------------------------------------------------------------------*
override method @gtlSortStatementStructInstruction display
{
  message "sort "
    + [variablePath stringRepresentation] 
    + " by "
    + [sortingKey stringRepresentation]
}

#-----------------------------------------------------------------------------*
override method @gtlTemplateInstruction display
{
  message "template "
    + if isGlobal then "" else "( " + [arguments stringRepresentation] + " ) " end
    + if ifExists then "if exists " else "" end
    + [fileName stringRepresentation]
    + if "" == prefix then " " else " in " + prefix + " " end
    + if ifExists & [instructionsIfNotFound length] > 0 then "or ..." else "" end
}

#-----------------------------------------------------------------------------*
override method @gtlEmitInstruction display
{
  message "! " + [rValue stringRepresentation]
}

#=============================================================================*
getter @gtlInstruction mayExecuteWithoutError
  ?let @gtlData unused context
  ?let @library unused lib
  ->@bool may
{
  may = true
}

#-----------------------------------------------------------------------------*
override getter @gtlDisplayStatementInstruction mayExecuteWithoutError
  ?let @gtlData context
  ?let @library lib
  ->@bool may
{
  may =  [variablePath exists !context !lib]
}


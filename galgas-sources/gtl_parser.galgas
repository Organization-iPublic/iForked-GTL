#-----------------------------------------------------------------------------*
#
#  @file gtl_parser.galgas
#
#  @section desc File description
#
#  Parsing of GTL.
#
#  @section copyright Copyright
#
#  Goil OIL compiler, part of Trampoline RTOS
#
#  Trampoline is copyright (c) CNRS, University of Nantes,
#  Ecole Centrale de Nantes
#  Trampoline is protected by the French intellectual property law.
#
#  This software is distributed under the GNU Public Licence V2.
#  Check the LICENSE file in the root directory of Trampoline
#
#  $Date$
#  $Rev$
#  $Author$
#  $URL$
#
#-----------------------------------------------------------------------------*

syntax gtl_parser (gtl_scanner) {

rule <gtl_expression>
  !@gtlExpression expression

rule <gtl_variable>
  !@gtlVarPath path

rule <gtl_variable_or_here>
  !@gtlVarPath variable
  !@bool hereInstead
  
#-----------------------------------------------------------------------------*
rule <gtl_start_symbol> !@gtlInstructionList program
{
  <gtl_instruction_list> ?program
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction_list> !@gtlInstructionList instructionList
{
  instructionList = .emptyList { }

  @string templateString = @string.retrieveAndResetTemplateString
  if templateString != "" then
    instructionList +=
      !@gtlTemplateStringInstruction.new{ !.here !templateString }
  end
  repeat
  while
    <gtl_instruction> ?@gtlInstruction instruction
    instructionList += !instruction
    @string templateString = @string.retrieveAndResetTemplateString
    if templateString != "" then
      instructionList +=
        !@gtlTemplateStringInstruction.new{ !.here !templateString }
    end
  end
}

#-----------------------------------------------------------------------------*
# emit parsing. Syntax is:
# ! expression
#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $!$ @location where = .here
  <gtl_expression> ?@gtlExpression expression
  
  instruction = @gtlEmitInstruction.new { !where !expression }
}

#-----------------------------------------------------------------------------*
# write to parsing. Syntax is:
# write to <executable> expression :
#   ...
# end write
#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  @bool isExecutable = false
  $write$ @location where = .here $to$
  select $executable$ isExecutable = true or end
  <gtl_expression> ?@gtlExpression fileName
  $:$
  <gtl_instruction_list> ?@gtlInstructionList instructionList
  $end$ $write$ 
  
  instruction = @gtlWriteToInstruction.new {
    !where !fileName !isExecutable !instructionList
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  @lstring prefix
  @bool ifExists = false
  @gtlInstructionList instructionList = .emptyList
  @gtlExpression fileName
  
  $template$ @location where = .here
  select
    $if$ $exists$
    ifExists = true
    <gtl_file_name> ?fileName
    select
      $in$ $identifier$ ?prefix
    or prefix = .new { !"" !@location.here } end
    select
      $or$
      <gtl_instruction_list> ?instructionList
      $end$ $template$
    or end
  or
    <gtl_file_name> ?fileName
    select
      $in$ $identifier$ ?prefix
    or prefix = .new { !"" !@location.here } end
  end
  
  instruction = @gtlTemplateInstruction.new {
    !where !prefix !fileName !ifExists !instructionList
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $?$ @location where = .here
  <gtl_variable> ?let @gtlVarPath columnConstantName
  
  instruction = @gtlGetColumnInstruction.new {
    !where !columnConstantName
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  @gtlThenElsifStatementList thenElsifList = .emptyList
  @gtlInstructionList elseList = .emptyList
  
  $if$ @location where = .here
  repeat
    <gtl_expression> ?@gtlExpression condition
    $then$
    <gtl_instruction_list> ?@gtlInstructionList instructionList
    
    thenElsifList += !condition !instructionList
  while
    $elsif$
  end
#--- else
  select
    $else$
    <gtl_instruction_list> ?elseList
  or end
#---
  $end$
  $if$
  
  instruction = @gtlIfStatementInstruction.new {
    !where !thenElsifList !elseList
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  @gtlInstructionList beforeList = .emptyList
  @gtlInstructionList doList = .emptyList
  @gtlInstructionList betweenList = .emptyList
  @gtlInstructionList afterList = .emptyList

  $foreach$ @location where = .here
  $identifier$ ?let @lstring variableName $in$
  <gtl_expression> ?@gtlExpression iterable
#--- before block
  select
    $before$
    <gtl_instruction_list> ?beforeList
  or end
#--- do block
  $do$
  <gtl_instruction_list> ?doList
#--- between block
  select
    $between$
    <gtl_instruction_list> ?betweenList
  or end
#--- after block
  select
    $after$
    <gtl_instruction_list> ?afterList
  or end
#---
  $end$
  $foreach$
  
  instruction = @gtlForeachStatementInstruction.new {
    !where !variableName !iterable !beforeList !betweenList !afterList !doList
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  @gtlInstructionList doList = .emptyList
  @gtlInstructionList betweenList = .emptyList
  @gtlExpressionList  iterable = .emptyList 

  $for$ @location where = .here
  $identifier$ ?let @lstring variableName
  $in$
  repeat
    <gtl_expression> ?@gtlExpression expression
    iterable += !expression
  while
    $,$
  end
#--- Do block
  $do$
  <gtl_instruction_list> ?doList
#--- between block
  select
    $between$
    <gtl_instruction_list> ?betweenList
  or end
#---
  $end$
  $for$
  
  instruction = @gtlForStatementInstruction.new {
    !where !variableName !iterable !betweenList !doList
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  @gtlInstructionList beforeList = .emptyList
  @gtlInstructionList betweenList = .emptyList
  @gtlInstructionList afterList = .emptyList
  @sint64 direction = 1LS
  
  $loop$ @location where = .here

  @gtlExpression step = @gtlTerminal.new {
    !where !@gtlInt.new { !where !1_G }
  }

  $identifier$ ?var  @lstring variableName
  $from$
  <gtl_expression> ?@gtlExpression start
  select
  or
    $up$
  or
    $down$ direction = -1LS
  end
  $to$
  <gtl_expression>  ?@gtlExpression stop
  select
    $step$
    <gtl_expression> ?step
  or end
#--- before block
  select
    $before$
    <gtl_instruction_list> ?beforeList
  or end
#--- do block
  $do$
  <gtl_instruction_list> ?@gtlInstructionList doList
#--- between block
  select
    $between$
    <gtl_instruction_list> ?betweenList
  or end
#--- after block
  select
    $after$
    <gtl_instruction_list> ?afterList
  or end
#---
  $end$
  $loop$
  
  instruction = @gtlLoopStatementInstruction.new {
    !where !variableName !start !stop !step !direction
    !beforeList !betweenList !afterList !doList
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $repeat$ @location where = .here
  <gtl_instruction_list> ?@gtlInstructionList continueList
  $while$
  <gtl_expression> ?@gtlExpression condition
  $do$
  <gtl_instruction_list> ?@gtlInstructionList doList
  $end$
  $repeat$
  
  instruction = @gtlRepeatStatementInstruction.new {
    !where !condition !continueList !doList
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $let$ @location where = .here
  <gtl_variable> ?@gtlVarPath variable
  select
    $:=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetInstruction.new { !where !variable !expression} 
  or
    $+=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetAddInstruction.new { !where !variable !expression} 
  or
    $-=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetSubstractInstruction.new { !where !variable !expression} 
  or
    $*=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetMultiplyInstruction.new { !where !variable !expression} 
  or
    $/=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetDivideInstruction.new { !where !variable !expression} 
  or
    $mod=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetModuloInstruction.new { !where !variable !expression} 
  or
    $<<=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetShiftLeftInstruction.new { !where !variable !expression} 
  or
    $>>=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetShiftRightInstruction.new { !where !variable !expression} 
  or
    $&=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetAndInstruction.new { !where !variable !expression} 
  or
    $|=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetOrInstruction.new { !where !variable !expression} 
  or
    $^=$
    <gtl_expression> ?@gtlExpression expression
    instruction = @gtlLetXorInstruction.new { !where !variable !expression} 
  end
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $error$ @location where = .here
  <gtl_variable_or_here> ?@gtlVarPath variable ?@bool hereInstead
  $:$
  <gtl_expression> ?@gtlExpression expression

  instruction = @gtlErrorStatementInstruction.new {
    !where !variable !hereInstead !expression
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $warning$ @location where = .here
  <gtl_variable_or_here> ?@gtlVarPath variable ?@bool hereInstead
  $:$
  <gtl_expression> ?@gtlExpression expression

  instruction = @gtlWarningStatementInstruction.new {
    !where !variable !hereInstead !expression
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $print$ @location where = .here
  <gtl_expression> ?@gtlExpression expression

  instruction = @gtlPrintStatementInstruction.new {
    !where !false !expression
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $println$ @location where = .here
  <gtl_expression> ?@gtlExpression expression

  instruction = @gtlPrintStatementInstruction.new {
    !where !true !expression
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $display$ @location where = .here
  <gtl_variable> ?@gtlVarPath variable

  instruction = @gtlDisplayStatementInstruction.new {
    !where !variable
  }
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $sort$ @location where = .here
  <gtl_variable> ?@gtlVarPath variable
  select
    @sortingKeyList sortList = .emptyList
    $by$
    repeat
      $identifier$ ?let @lstring key
      <gtl_sorting_order> ?@lsint order
      sortList += !key !order
    while $,$ end
    
    instruction = @gtlSortStatementStructInstruction.new {
      !where !variable !sortList
    }    
  or
    <gtl_sorting_order> ?@lsint order
    
    instruction = @gtlSortStatementInstruction.new {
      !where !variable !order
    }
  end
}

#-----------------------------------------------------------------------------*
rule <gtl_instruction> !@gtlInstruction instruction
{
  $tab$ @location where = .here
  <gtl_expression> ?@gtlExpression expression
  
  instruction = @gtlTabStatementInstruction.new {
    !where !expression
  }  
}

#-----------------------------------------------------------------------------*
rule <gtl_file_name>
  !@gtlExpression expression
{
  select
    $identifier$ ?let @lstring fileName
    expression = @gtlTerminal.new {
      !@location.here !@gtlString.new {
        ![fileName location] ![fileName string]
      }
    }
  or
    $from$
    <gtl_expression> ?expression
  end
}

#-----------------------------------------------------------------------------*
rule <gtl_sorting_order>
  !@lsint order {
  select
    $>$ 
    order = @lsint. new { !-1s !@location.here}
  or
    $<$
    order = @lsint. new { !1s !@location.here}
  end
}

} # end of syntax

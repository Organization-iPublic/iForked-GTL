#---------------------------------------------------------------------------*
#
#  @file gtl_expression_parser.galgas
#
#  @section desc File description
#
#  Expressions parser for GTL.
#
#  @section copyright Copyright
#
#  Goil OIL compiler, part of Trampoline RTOS
#
#  Trampoline is copyright (c) CNRS, University of Nantes,
#  Ecole Centrale de Nantes
#  Trampoline is protected by the French intellectual property law.
#
#  This software is distributed under the GNU Public Licence V2.
#  Check the LICENSE file in the root directory of Trampoline
#
#  $Date$
#  $Rev$
#  $Author$
#  $URL$
#
#---------------------------------------------------------------------------*

syntax gtl_expression_parser (gtl_scanner) {

#------------------------------------------------------------------------------*
#   E X P R E S S I O N                                                        *
#------------------------------------------------------------------------------*

rule <gtl_expression>
  !@gtlExpression expression
{
  <gtl_relation_term> ?expression
  repeat
  while
    $|$ @location opLocation = .here
    <gtl_relation_term> ?@gtlExpression rightSon
    expression = @gtlOrExpression.new { !opLocation !expression !rightSon }
  while
    $^$ @location opLocation = .here
    <gtl_relation_term> ?@gtlExpression rightSon
    expression = @gtlXorExpression.new { !opLocation !expression !rightSon }
  end
}

#------------------------------------------------------------------------------*
#   R E L A T I O N    T E R M                                                 *
#------------------------------------------------------------------------------*

rule <gtl_relation_term>
  !@gtlExpression expression
{
  <gtl_relation_factor> ?expression
  repeat
  while
    $&$ @location opLocation = .here
    <gtl_relation_factor> ?@gtlExpression rightSon
    expression = @gtlAndExpression.new { !opLocation !expression !rightSon }
  end
}

#------------------------------------------------------------------------------*
#   R E L A T I O N    F A C T O R                                             *
#------------------------------------------------------------------------------*

rule <gtl_relation_factor>
  !@gtlExpression expression
{
  <gtl_simple_expression> ?expression
  select
  or
    $==$ @location opLocation = .here
    <gtl_simple_expression> ?@gtlExpression rightSon
    expression = @gtlEqualExpression.new {
      !opLocation !expression !rightSon
    }
  or
    $!=$ @location opLocation = .here
    <gtl_simple_expression> ?@gtlExpression rightSon
    expression = @gtlNotEqualExpression.new {
      !opLocation !expression !rightSon
    }
  or
    $<=$ @location opLocation = .here
    <gtl_simple_expression> ?@gtlExpression rightSon
    expression = @gtlLowerOrEqualExpression.new {
      !opLocation !expression !rightSon
    }
  or
    $>=$ @location opLocation = .here
    <gtl_simple_expression> ?@gtlExpression rightSon
    expression = @gtlGreaterOrEqualExpression.new {
      !opLocation !expression !rightSon
    }
  or
    $>$ @location opLocation = .here
    <gtl_simple_expression> ?@gtlExpression rightSon
    expression = @gtlGreaterThanExpression.new {
      !opLocation !expression !rightSon
    }
  or
    $<$ @location opLocation = .here
    <gtl_simple_expression> ?@gtlExpression rightSon
    expression = @gtlLowerThanExpression.new {
      !opLocation !expression !rightSon
    }
  end
}

#------------------------------------------------------------------------------*
#   S I M P L E    E X P R E S S I O N                                         *
#------------------------------------------------------------------------------*

rule <gtl_simple_expression>
  !@gtlExpression expression
{
  <gtl_term> ?expression
  repeat
  while 
    $<<$ @location opLocation = .here
    <gtl_term> ?@gtlExpression rightSon
    expression = @gtlShiftLeftExpression.new {
      !opLocation !expression !rightSon
    }
  while 
    $>>$ @location opLocation = .here
    <gtl_term> ?@gtlExpression rightSon
    expression = @gtlShiftRightExpression.new {
      !opLocation !expression !rightSon
    }
  while 
    $+$ @location opLocation = .here
    <gtl_term> ?@gtlExpression rightSon
    expression = @gtlAddExpression.new {
      !opLocation !expression !rightSon
    }
  while 
    $.$ @location opLocation = .here
    <gtl_term> ?@gtlExpression rightSon
    expression = @gtlAddExpression.new {
      !opLocation !expression !rightSon
    }
  while 
    $-$ @location opLocation = .here
    <gtl_term> ?@gtlExpression rightSon
    expression = @gtlSubstractExpression.new {
      !opLocation !expression !rightSon
    }
  end
}

#------------------------------------------------------------------------------*
#   T E R M                                                                    *
#------------------------------------------------------------------------------*

rule <gtl_term>
  !@gtlExpression expression
{
  <gtl_factor> ?expression
  repeat
  while 
    $*$ @location opLocation = .here
    <gtl_factor> ?@gtlExpression rightSon
    expression = @gtlMultiplyExpression.new {
      !opLocation !expression !rightSon
    }
  while 
    $/$ @location opLocation = .here
    <gtl_factor> ?@gtlExpression rightSon
    expression = @gtlDivideExpression.new {
      !opLocation !expression !rightSon
    }
  while 
    $mod$ @location opLocation = .here
    <gtl_factor> ?@gtlExpression rightSon
    expression = @gtlModulusExpression.new {
      !opLocation !expression !rightSon
    }
  end
}

#------------------------------------------------------------------------------*
#   F A C T O R    :    ( EXPRESSION )                                         *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $($ @location opLocation = .here
  <gtl_expression> ?@gtlExpression factorExpression
  expression = @gtlParenthesizedExpression.new {
    !opLocation
    !factorExpression
  }
  $)$
}

#------------------------------------------------------------------------------*
#   F A C T O R    :    not FACTOR                                             *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $not$ @location opLocation = .here
  <gtl_factor> ?@gtlExpression notExpression
  expression = @gtlNotExpression.new { !opLocation !notExpression }
}

#------------------------------------------------------------------------------*
#   F A C T O R    :    ~ FACTOR                                               *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $~$ @location opLocation = .here
  <gtl_factor> ?@gtlExpression notExpression
  expression = @gtlNotExpression.new { !opLocation !notExpression }
}

#------------------------------------------------------------------------------*
#   F A C T O R    :    - FACTOR                                               *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $-$ @location opLocation = .here
  <gtl_factor> ?@gtlExpression minusExpression
  expression = @gtlMinusExpression.new { !opLocation !minusExpression }
}

#------------------------------------------------------------------------------*
#   F A C T O R    :    + FACTOR                                               *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $+$ @location opLocation = .here
  <gtl_factor> ?@gtlExpression plusExpression
  expression = @gtlPlusExpression.new { !opLocation !plusExpression }
}

#------------------------------------------------------------------------------*
#   F A C T O R    :    true                                                   *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $yes$ @location opLocation = .here
  expression = @gtlTerminal.new{
    !opLocation !@gtlBool.new { !opLocation !true }
  }
}

#------------------------------------------------------------------------------*
#   F A C T O R    :    false                                                  *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $no$
  expression = @gtlTerminal.new{
    !.here !@gtlBool.new { !.here !false }
  }
}

#------------------------------------------------------------------------------*
#   F A C T O R    :    an integer value                                       *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $signed_literal_integer_bigint$ ?let @lbigint literalInteger
  expression = @gtlTerminal.new{
    !.here !@gtlInt.new { !.here ![literalInteger bigint] }
  }
}

#------------------------------------------------------------------------------*
#   F A C T O R    :    a literal string value                                 *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $string$ ?let @lstring literalString
  expression = @gtlTerminal.new{
    !.here !@gtlString.new { !.here ![literalString string] }
  }
}

#------------------------------------------------------------------------------*
#                         F A C T O R                                          *
#   template getter call :   [expression getter : ... ]                        *
#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $[$
  <gtl_expression> ?@gtlExpression target
  $identifier$ ?let @lstring getterName
  @gtlExpressionList argumentList = .emptyList
  select
  or
    $:$
    repeat
      <gtl_expression> ?@gtlExpression argument
      argumentList += !argument
    while
      $,$
    end
  end
  $]$
  expression = @gtlGetterCallExpression.new {
    !.here
    !target
    !getterName
    !argumentList
  }
}

#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  <gtl_variable> ?let @gtlVarPath path
  select
    expression = @gtlVarRef.new { !.here !path }
  or
    if [path length] > 1 then
      error .here : "illegal function name"
    end
    @gtlExpressionList functionArguments = .emptyList
    $($
    repeat
      <gtl_expression> ?@gtlExpression expression
      functionArguments += !expression
    while
      $,$
    end
    $)$
    @lstring functionName = [[path itemAtIndex !0] field]
    expression = @gtlFunctionCallExpression.new {
      !.here
      !functionName
      !functionArguments
    }
  end
}

#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $exists$ <gtl_variable> ?let @gtlVarPath path
  select
    $default$
    $($
    <gtl_expression> ?@gtlExpression defaultExpression
    $)$
    expression = @gtlExistsDefaultExpression.new {
      !.here !path !defaultExpression
    }
  or
    expression = @gtlExistsExpression.new { !.here !path }
  end
}

#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $typeof$ <gtl_variable> ?let @gtlVarPath path
  expression = @gtlTypeOfExpression.new { !.here !path }
}

#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $true$
  expression = @gtlTerminal.new {
    !.here
    !@gtlBool.new { 
      !.here
      !true
    }
  }
}

rule <gtl_factor>
  !@gtlExpression expression
{
  $false$
  expression = @gtlTerminal.new {
    !.here
    !@gtlBool.new { 
      !.here
      !false
    }
  }
}

#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $@$ $identifier$ ?let @lstring typeName
  @string name = [typeName string]
  @gtlType type
  if    name == "int"    then type = .new { ![typeName location] !`@gtlInt }
  elsif name == "float"  then type = .new { ![typeName location] !`@gtlFloat }
  elsif name == "string" then type = .new { ![typeName location] !`@gtlString }
  elsif name == "bool"   then type = .new { ![typeName location] !`@gtlBool }
  elsif name == "struct" then type = .new { ![typeName location] !`@gtlStruct }
  elsif name == "list"   then type = .new { ![typeName location] !`@gtlList }
  elsif name == "map"    then type = .new { ![typeName location] !`@gtlMap }
  elsif name == "enum"   then type = .new { ![typeName location] !`@gtlEnum }
  else error .here : name + " does not name a type" : type
  end
  expression = @gtlTerminal.new { ![typeName location] !type }
}

#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $emptylist$
  expression = @gtlTerminal.new {
    !.here
    !@gtlList.new { 
      !.here
      !.emptyList
    }
  }
}

#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $emptymap$
  expression = @gtlTerminal.new {
    !.here
    !@gtlMap.new { 
      !.here
      !.emptyMap
    }
  }
}

#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $mapof$
  <gtl_expression> ?@gtlExpression data
  select
    $by$
    $identifier$ ?var @lstring key
    expression = @gtlMapOfListExpression.new {
      !.here
      !data
      !key
    }
  or 
    $end$
    expression = @gtlMapOfStructExpression.new {
      !.here
      !data
    }
  end
}

#------------------------------------------------------------------------------*

rule <gtl_factor>
  !@gtlExpression expression
{
  $listof$
  <gtl_expression> ?let @gtlExpression data
  expression = @gtlListOfExpression.new { !.here !data }
  $end$
}

#------------------------------------------------------------------------------*

rule <gtl_list_item>
  !@gtlExpression expression
{
  select
    <gtl_expression> ?expression
  or
    ${$
    @gtlExpressionMap fields = .emptyMap
    repeat
      $identifier$ ?let @lstring fieldName
      $:$
      <gtl_expression> ?@gtlExpression fieldExpression
      [!?fields put !fieldName !fieldExpression]
    while $,$
    end
    $}$
    expression = @gtlLiteralStructExpression.new { !.here !fields }
  end
}

rule <gtl_factor>
  !@gtlExpression expression
{
  $@[$
  @gtlExpressionList expressionList = .emptyList
  repeat
    <gtl_list_item> ?@gtlExpression listItem
    expressionList += !listItem
  while $,$
  end
  $]$
  expression = @gtlLiteralListExpression.new { !.here !expressionList }
}

#------------------------------------------------------------------------------*

rule <gtl_variable>
  !@gtlVarPath path
{
  path = .emptyList
  repeat
    $identifier$ ?var @lstring variableName
    select
      $[$
      <gtl_expression> ?let @gtlExpression expression
      $]$
      path += !@gtlVarItemCollection.new { !variableName !expression }
    or
      path += !@gtlVarItemField.new { !variableName }
    end
  while
    $::$
  end
}

#------------------------------------------------------------------------------*

rule <gtl_variable_or_here>
  !@gtlVarPath path
  !@bool hereInstead
{
  select
    $here$ path = .emptyList
    hereInstead = true
  or
    <gtl_variable> ?path
    hereInstead = false
  end
}

}

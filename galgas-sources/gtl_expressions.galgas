#-----------------------------------------------------------------------------*
#
#  @file gtl_expressions.galgas
#
#  @section desc File description
#
#  expressions in GTL.
#
#  @section copyright Copyright
#
#  Goil OIL compiler, part of Trampoline RTOS
#
#  Trampoline is copyright (c) CNRS, University of Nantes,
#  Ecole Centrale de Nantes
#  Trampoline is protected by the French intellectual property law.
#
#  This software is distributed under the GNU Public Licence V2.
#  Check the LICENSE file in the root directory of Trampoline
#
#  $Date$
#  $Rev$
#  $Author$
#  $URL$
#
#-----------------------------------------------------------------------------*

#=============================================================================*
# A @gtlVarItem is a part of a variable path.
# For instance A::B["e"]::C::D[3] is a path. A is a struct, B is a field of
# A and is a map, ["e"] is the element of the map with key "e". This element
# is a struct with field C which is itself a struct with field D which is a
# list and we reference the element at index 3.
#-----------------------------------------------------------------------------*
abstract class @gtlVarItem { @lstring field }

#-----------------------------------------------------------------------------*
# abstact method to set a field in a context
#-----------------------------------------------------------------------------*
abstract method @gtlVarItem set
  ?!     @gtlVarMap  context
  ?  let @gtlVarMap  vars
  ?  let @library    lib
  ?  let @gtlVarPath path
  ?  let @gtlData    data

#-----------------------------------------------------------------------------*
# abstact getter to get a field in a context
#-----------------------------------------------------------------------------*
abstract getter @gtlVarItem get
  ? let @gtlVarMap  context
  ? let @gtlVarMap  vars
  ? let @library    lib
  ? let @gtlVarPath path
  -> @gtlData result
  
#-----------------------------------------------------------------------------*
# abstact getter to test the existence of a field in a context
#-----------------------------------------------------------------------------*
abstract getter @gtlVarItem exists
  ? let @gtlVarMap  context
  ? let @gtlVarMap  vars
  ? let @library    lib
  ? let @gtlVarPath path
  -> @bool result
  
#=============================================================================*
# Scalar struct field, ie A or C in the example above
#-----------------------------------------------------------------------------*
class @gtlVarItemField : @gtlVarItem { }

#-----------------------------------------------------------------------------*
# set a scalar field
#-----------------------------------------------------------------------------*
override method @gtlVarItemField set
  ?!     @gtlVarMap  context
  ?  let @gtlVarMap  vars
  ?  let @library    lib
  ?  let @gtlVarPath path
  ?  let @gtlData    data
{ 
  if [path length] == 0 then
    # at the end, set the variable in the context
    if [context hasKey ![field string]] then
      # A field with the same name exists, replace it
      [!?context setValueForKey !data ![field string]]
    else
      # The field does not exist, add it
      [!?context put !field !data]
    end
  else
    @gtlVarMap subContext = .emptyMap{}
    # not at the end, get and set the subcontext
    if [context hasKey ![field string]] then
      # The variable/field already exists
      # get the variable
      [context get !field ?var @gtlData variable]
      cast variable
        case == @gtlStruct structVar :
          # it is a struct
          subContext = [structVar value]
      end
      # set in the subcontext
      [[path itemAtIndex !0] set
        !?subContext
        !vars
        !lib
        ![path subListFromIndex !1]
        !data
      ]
      # update with the result
      [!?context setValueForKey
        !@gtlStruct.new{![field location] !subContext}
        ![field string]
      ]
    else
      # set in the subcontext
      [[path itemAtIndex !0] set
        !?subContext
        !vars
        !lib
        ![path subListFromIndex !1]
        !data
      ]
      # update with the result
      [!?context put !field !@gtlStruct.new{![field location] !subContext}]
    end
  end
}

#-----------------------------------------------------------------------------*
# getter to get a field in a context
#-----------------------------------------------------------------------------*
override getter @gtlVarItemField get
  ? let @gtlVarMap  context
  ? let @gtlVarMap  vars
  ? let @library    lib
  ? let @gtlVarPath path
  -> @gtlData result
{
  if [path length] == 0 then
    # at the end, get the variable in the context
    [context get !field ?result]
  else
    # not at the end, get and set the subcontext
    [context get !field ?let @gtlData subContextData]
    cast subContextData
    case == @gtlStruct structVar:
      result = [[path itemAtIndex !0] get
                 ![structVar value]
                 !vars
                 !lib
                 ![path subListFromIndex !1]
               ]
    else
      error [field location] : [field string]+"is not a struct" : result
    end
  end
}

#-----------------------------------------------------------------------------*
# getter to test the existence of a field in a context
#-----------------------------------------------------------------------------*
override getter @gtlVarItemField exists
  ? let @gtlVarMap  context
  ? let @gtlVarMap  vars
  ? let @library    lib
  ? let @gtlVarPath path
  -> @bool result
{
  if [path length] == 0 then
    # at the end, get the variable in the context
    result = if [context hasKey ![field string]] then true else false end
  else
    # not at the end
    if [context hasKey ![field string]] then
      [context get !field ?let @gtlData subContextData]
      cast subContextData
      case == @gtlStruct structVar:
      result = [[path itemAtIndex !0] exists
                 ![structVar value]
                 !vars
                 !lib
                 ![path subListFromIndex !1]
               ]
      else
        result = false
      end
    else
      result = false
    end
  end
}

#=============================================================================*
# Collection field, ie B or D in the example above
#-----------------------------------------------------------------------------*
class @gtlVarItemCollection : @gtlVarItem { @gtlExpression key }

#-----------------------------------------------------------------------------*
# set a map item field
#-----------------------------------------------------------------------------*
override method @gtlVarItemCollection set
  ?!    @gtlVarMap  context
  ? let @gtlVarMap  vars
  ? let @library    lib
  ? let @gtlVarPath path
  ? let @gtlData    data
{
  # evaluate the expression to a string
  cast [key eval !vars !lib]
  
  case == @gtlString keyValue :
    if [path length] == 0 then
      # at the end, set the variable in the context
      # 2 cases :
      # 1) the variable already exists and is a map, set or replace the element
      # 2) the variable already exists and is not a map, replace it with a map
      #    with the item set
      # 3) the variable does not exist, create a map and add the item
      if [context hasKey ![field string]] then
        # A field with the same name exists, get it
        [!?context del !field ?var @gtlData item]
        cast item
        case == @gtlMap mapItem :
          @gtlVarMap mapToSet = [mapItem value]
          if [mapToSet hasKey ![keyValue value]] then
            # update it
            [!?mapToSet setValueForKey !data ![keyValue value]]
          else
            # create it
            [!?mapToSet put
              !@lstring.new{![keyValue value] ![key where]}
              !data
            ]
          end
          # update the context
          [!?context put !field !@gtlMap.new{![mapItem where] !mapToSet}]
        else
          # not a map, create one
          @gtlVarMap mapToSet = .emptyMap{}
          [!?mapToSet put
            !@lstring.new{![keyValue value] ![key where]}
            !data
          ]
          [!?context put !field !@gtlMap.new{![field location] !mapToSet}]
        end  
      else
        # The field does not exist, add it
        @gtlVarMap mapToSet = .emptyMap{}
        [!?mapToSet put
          !@lstring.new{![keyValue value] ![key where]}
          !data
        ]
        [!?context put !field !@gtlMap.new{![field location] !mapToSet}]
      end
    else
      @gtlVarMap subContext = .emptyMap{}
      # not at the end, get and set the subcontext
      if [context hasKey ![field string]] then
        # get the variable
        [!?context del !field ?var @gtlData variable]
        cast variable
        case == @gtlMap mapVar :
          # it is a map, get the item corresponding to the key
          @gtlVarMap theMap = [mapVar value]
          if [theMap hasKey ![keyValue value]] then
            [!?theMap del
              !@lstring.new{![keyValue value] ![key where]}
              ?let @gtlData subField
            ]
            cast subField
              case == @gtlStruct subStruct:
                subContext = [subStruct value]
            end
          end
          [[path itemAtIndex !0] set
            !?subContext
            !vars
            !lib
            ![path subListFromIndex !1]
            !data
          ]
          [!?theMap put !keyValue !@gtlStruct.new{![field location] !subContext}]
          [!?context put !field !@gtlMap.new{![field location] !theMap}]
        else
          # set in the subcontext
          [[path itemAtIndex !0] set
            !?subContext
            !vars
            !lib
            ![path subListFromIndex !1]
            !data
          ]
          # update with the result
          [!?context put !field !@gtlMap.new{![field location] !subContext}]
        end
      else
        message "OK\n"
        # set in the subcontext
        [[path itemAtIndex !0] set
          !?subContext
          !vars
          !lib
          ![path subListFromIndex !1]
          !data
        ]
        # update with the result
        [!?context put !field !@gtlMap.new{![field location] !subContext}]
      end
    end
    
  case == @gtlInt idxValue:
    if [path length] == 0 then
      # at the end, set the variable in the context
      # 2 cases :
      # 1) the variable already exists and is a list, set or replace the element
      # 2) the variable already exists and is not a list, replace it with a list
      #    with the item set
      # 3) the variable does not exist, create a list and add the item
      if [context hasKey ![field string]] then
        # A field with the same name exists, get it
        [!?context del !field ?var @gtlData item]
        cast item
        case == @gtlList listItem :
          @list listToSet = [listItem value]
          if [listToSet length] > [[idxValue value] uint] then
            # update it
            [!?listToSet setValueAtIndex !data ![[idxValue value] uint]]
          else
            # element does not exist, emit an error
            error [idxValue where] : "index "+[idxValue value]+" out of range"
          end
          # update the context
          [!?context put
            !field
            !@gtlList.new{![data where] !listToSet}
          ]
        else
          # not a list, it is an error since setting an element at index
          # supposes the element exists
          error [field location] : "field/variable "+[field string]+" is not a list"
        end
      else
        # The field does not exist, emit an error
        error [field location] : "list "+[field string]+" does not exists"
      end
    else
      @gtlVarMap subContext = .emptyMap{}
      # not at the end, get and set the subcontext
      if [context hasKey ![field string]] then
        # get the variable
        [!?context del !field ?var @gtlData variable]
        cast variable
        case == @gtlList listVar :
          # it is a map, get the item corresponding to the key
          @list theList = [listVar value]
          if [theList length] > [[idxValue value] uint] then
            cast [theList valueAtIndex ![[idxValue value] uint]]
            case == @gtlStruct subStruct:
                subContext = [subStruct value]
            end
            [[path itemAtIndex !0] set
              !?subContext
              !vars
              !lib
              ![path subListFromIndex !1]
              !data
            ]
            [!?context setValueForKey
              !@gtlMap.new{![field location] !subContext}
              ![field string]
            ]
          else
            # out of range index, emit an error
            error [idxValue where] : "index "+[idxValue value]+" out of range"
          end
        else
          # not a list, it is an error since setting an element at index
          # supposes the element exists
          error [field location] : "field/variable "+[field string]+" is not a list"
        end
      else
        # The field does not exist, emit an error
        error [field location] : "list "+[field string]+" does not exists"
      end
    end
    
  else
    # not a string, emit error
    error [key where] : "Key does not evaluate to a string or an int"
  end
}

#-----------------------------------------------------------------------------*
# getter to get a map field in a context
#-----------------------------------------------------------------------------*
override getter @gtlVarItemCollection get
  ? let @gtlVarMap  context
  ? let @gtlVarMap  vars
  ? let @library    lib
  ? let @gtlVarPath path
  -> @gtlData result
{
  cast [key eval !vars !lib]
  
  case == @gtlString keyValue :
    # get the map
    [context get !field ?let @gtlData item]
    cast item
    case == @gtlMap mapItem :
      [[mapItem value] get
        !@lstring.new{![keyValue value] ![key where]}
        ?let @gtlData mapItemField
      ]
      if [path length] == 0 then
        # at the end, get the variable in the context
        result = mapItemField
      else
        # not at the end, get and set the subcontext
        cast mapItemField
        case == @gtlStruct structVar:
          result = [[path itemAtIndex !0] get
                     ![structVar value]
                     !vars
                     !lib
                     ![path subListFromIndex !1]
                   ]
        else
          error [field location] : [field string]+" is not a struct" : result
        end
      end
    else
      error [item where] : "field "+[field string]+" is not a map" : result
    end
    
  case == @gtlInt idxValue :
    # get the list
    [context get !field ?let @gtlData item]
    cast item
    case == @gtlList listItem :
      @gtlData listItemElement = [[listItem value] valueAtIndex
                                   ![[idxValue value] uint]]
      if [path length] == 0 then
        # at the end, get the variable in the context
        result = listItemElement
      else
        # not at the end, get and set the subcontext
        cast listItemElement
        case == @gtlStruct structVar:
          result = [[path itemAtIndex !0] get
                     ![structVar value]
                     !vars
                     !lib
                     ![path subListFromIndex !1]
                   ]
        else
          error [field location] : [field string]+" is not a struct" : result
        end
      end
    else
      error [item where] : "field "+[field string]+" is not a list" : result
    end
    
  else
    # not a string, emit error
    error [key where] : "Key does not evaluate to a string or an int" : result
  end
}

#-----------------------------------------------------------------------------*
# getter to test the existence of a collection field in a context
#-----------------------------------------------------------------------------*
override getter @gtlVarItemCollection exists
  ? let @gtlVarMap  context
  ? let @gtlVarMap  vars
  ? let @library    lib
  ? let @gtlVarPath path
  -> @bool result
{
  cast [key eval !vars !lib]
  
  case == @gtlString keyValue :
    if [context hasKey ![field string]] then
      # get the map
      [context get !field ?let @gtlData item]
      cast item
      case == @gtlMap mapItem :
        if [[mapItem value] hasKey ![keyValue value]] then
          if [path length] == 0 then
            # at the end, get the variable in the context
            result = true
          else
            [[mapItem value] get
              !@lstring.new{![keyValue value] ![key where]}
              ?let @gtlData mapItemField
            ]
            # not at the end, get and set the subcontext
            cast mapItemField
            case == @gtlStruct structVar:
              result = [[path itemAtIndex !0] exists
                         ![structVar value]
                         !vars
                         !lib
                         ![path subListFromIndex !1]
                       ]
            else
              result = false
            end
          end
        else
          result = false
        end
      else
        result = false
      end
    else
      result = false
    end
  case == @gtlInt idxValue :
    if [context hasKey ![field string]] then
      # get the list
      [context get !field ?let @gtlData item]
      cast item
      case == @gtlList listItem :
        if [[listItem value] length] < [[idxValue value] uint] then
          if [path length] == 0 then
            # at the end, get the variable in the context
            result = true
          else
            @gtlData listItemElement = [[listItem value] valueAtIndex
                                         ![[idxValue value] uint]]
            # not at the end, get and set the subcontext
            cast listItemElement
            case == @gtlStruct structVar:
              result = [[path itemAtIndex !0] exists
                         ![structVar value]
                         !vars
                         !lib
                         ![path subListFromIndex !1]
                       ]
            else
              result = false
            end
          end
        else
          result = false
        end
      else
        result = false
      end
    else
      result = false
    end
  else
    # not a string
    result = false
  end
}

#=============================================================================*
# A variable path is a list of variable items
#-----------------------------------------------------------------------------*
list @gtlVarPath {
  @gtlVarItem item
}

#-----------------------------------------------------------------------------*
# Set a data in a path
#-----------------------------------------------------------------------------*
method @gtlVarPath setMe
  ?!@gtlVarMap      context
  ? let @library    lib
  ? let @gtlData    data
{
  if [self length] > 0 then
    @gtlVarItem item = [self itemAtIndex !0]
    [item set !?context !context !lib ![self subListFromIndex !1] !data]
  else
    error .here : "INTERNAL ERROR. A @gtlVarPath should not be an empty list"
  end
}

#-----------------------------------------------------------------------------*
# Get a data in a path
#-----------------------------------------------------------------------------*
getter @gtlVarPath get
  ?let @gtlVarMap context
  ? let @library  lib
  -> @gtlData     variableValue
{
  if [self length] > 0 then
    @gtlVarItem item = [self itemAtIndex !0]
    variableValue = [item get !context !context !lib ![self subListFromIndex !1]]
  else
    error .here : "INTERNAL ERROR. A @gtlVarPath should not be an empty list"
    : variableValue
  end
}

#-----------------------------------------------------------------------------*
# test the existence of a path
#-----------------------------------------------------------------------------*
getter @gtlVarPath exists
  ?let @gtlVarMap context
  ?let @library  lib
  -> @bool result
{
  if [self length] > 0 then
    @gtlVarItem item = [self itemAtIndex !0]
    result = [item exists !context !context !lib ![self subListFromIndex !1]]
  else
    error .here : "INTERNAL ERROR. A @gtlVarPath should not be an empty list"
    : result
  end
}

#-----------------------------------------------------------------------------*
# location of a path is the location of the last element
#-----------------------------------------------------------------------------*
getter @gtlVarPath location -> @location where
{
  @gtlVarItem lastOne
  [self last ?lastOne]
  where = [[lastOne field] location]
}

#=============================================================================*
# abstract classes for an expression
#-----------------------------------------------------------------------------*
abstract class @gtlExpression { @location where }

getter @gtlExpression location -> @location result { result = where }

abstract class @gtlUnaryExpression : @gtlExpression {
  @gtlExpression son
}
abstract class @gtlBinaryExpression : @gtlExpression {
  @gtlExpression lSon
  @gtlExpression rSon
}

abstract getter @gtlExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result

#=============================================================================*
# Expression list
#-----------------------------------------------------------------------------*
list @gtlExpressionList { @gtlExpression expression }

#=============================================================================*
# class for a literal terminal
#-----------------------------------------------------------------------------*
class @gtlTerminal : @gtlExpression { @gtlData value }

override getter @gtlTerminal eval
  ? let @gtlVarMap  unused gtlVariableMap
  ? let @library    unused lib
  -> @gtlData result
{
  result = value
}

#=============================================================================*
# class for a variable reference
#-----------------------------------------------------------------------------*
class @gtlVarRef : @gtlExpression { @gtlVarPath variableName }

override getter @gtlVarRef eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [variableName get !gtlVariableMap !lib]
  [!?result setWhere !where]
}

#=============================================================================*
# classes for unary expressions
#-----------------------------------------------------------------------------*
# @gtlParenthesizedExpression : ( son )
#-----------------------------------------------------------------------------*
class @gtlParenthesizedExpression : @gtlUnaryExpression {}

override getter @gtlParenthesizedExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [son eval !gtlVariableMap !lib]
  [!?result setWhere !where]
}

#-----------------------------------------------------------------------------*
# @gtlMinusExpression : unary -. Does a - son
#-----------------------------------------------------------------------------*
class @gtlMinusExpression : @gtlUnaryExpression {}

override getter @gtlMinusExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[son eval !gtlVariableMap !lib] minusOp]
}

#-----------------------------------------------------------------------------*
# @gtlPlusExpression : unary +. Does a + son 
#-----------------------------------------------------------------------------*
class @gtlPlusExpression : @gtlUnaryExpression {}

override getter @gtlPlusExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[son eval !gtlVariableMap !lib] plusOp]
}

#-----------------------------------------------------------------------------*
# @gtlTildeExpression : unary bitwise not or boolean not. Does a ~ son 
#-----------------------------------------------------------------------------*
class @gtlNotExpression : @gtlUnaryExpression {}

override getter @gtlNotExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[son eval !gtlVariableMap !lib] notOp]
}

#=============================================================================*
# classes for binary expressions
#-----------------------------------------------------------------------------*
# @gtlAddExpression : binary add. Does a lSon + rSon
#-----------------------------------------------------------------------------*
class @gtlAddExpression : @gtlBinaryExpression {}

override getter @gtlAddExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] addOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlSubstractExpression : binary substract. Does a lSon - rSon
#-----------------------------------------------------------------------------*
class @gtlSubstractExpression : @gtlBinaryExpression {}

override getter @gtlSubstractExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] subOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlMultiplyExpression : binary multiply. Does a lSon * rSon
#-----------------------------------------------------------------------------*
class @gtlMultiplyExpression : @gtlBinaryExpression {}

override getter @gtlMultiplyExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] mulOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlDivideExpression : binary divide. Does a lSon / rSon
#-----------------------------------------------------------------------------*
class @gtlDivideExpression : @gtlBinaryExpression {}

override getter @gtlDivideExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] divOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlModulusExpression : binary modulus. Does a lSon mod (or %) rSon
#-----------------------------------------------------------------------------*
class @gtlModulusExpression : @gtlBinaryExpression {}

override getter @gtlModulusExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] modOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlAndExpression : binary and. Does a lSon & rSon
#-----------------------------------------------------------------------------*
class @gtlAndExpression : @gtlBinaryExpression {}

override getter @gtlAndExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] andOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlOrExpression : binary or. Does a lSon | rSon
#-----------------------------------------------------------------------------*
class @gtlOrExpression : @gtlBinaryExpression {}

override getter @gtlOrExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] orOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlXorExpression : binary or. Does a lSon ^ rSon
#-----------------------------------------------------------------------------*
class @gtlXorExpression : @gtlBinaryExpression {}

override getter @gtlXorExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] xorOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlShiftLeftExpression : Does a lSon << rSon
#-----------------------------------------------------------------------------*
class @gtlShiftLeftExpression : @gtlBinaryExpression {}

override getter @gtlShiftLeftExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] slOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlShiftRightExpression : Does a lSon >> rSon
#-----------------------------------------------------------------------------*
class @gtlShiftRightExpression : @gtlBinaryExpression {}

override getter @gtlShiftRightExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] srOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlNotEqualExpression : Does a lSon != rSon
#-----------------------------------------------------------------------------*
class @gtlNotEqualExpression : @gtlBinaryExpression {}

override getter @gtlNotEqualExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] neqOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlEqualExpression : Does a lSon == rSon
#-----------------------------------------------------------------------------*
class @gtlEqualExpression : @gtlBinaryExpression {}

override getter @gtlEqualExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] eqOp 
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlLowerThanExpression : Does a lSon < rSon
#-----------------------------------------------------------------------------*
class @gtlLowerThanExpression : @gtlBinaryExpression {}

override getter @gtlLowerThanExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] ltOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlLowerOrEqualExpression : Does a lSon < rSon
#-----------------------------------------------------------------------------*
class @gtlLowerOrEqualExpression : @gtlBinaryExpression {}

override getter @gtlLowerOrEqualExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] leOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlGreaterThanExpression : Does a lSon < rSon
#-----------------------------------------------------------------------------*
class @gtlGreaterThanExpression : @gtlBinaryExpression {}

override getter @gtlGreaterThanExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] gtOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlGreaterOrEqualExpression : Does a lSon < rSon
#-----------------------------------------------------------------------------*
class @gtlGreaterOrEqualExpression : @gtlBinaryExpression {}

override getter @gtlGreaterOrEqualExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = [[lSon eval !gtlVariableMap !lib] geOp
           ![rSon eval !gtlVariableMap !lib]]
}

#-----------------------------------------------------------------------------*
# @gtlGetterCallExpression : Does a getter call
#-----------------------------------------------------------------------------*
class @gtlGetterCallExpression : @gtlExpression {
  @gtlExpression     target
  @lstring           getterName
  @gtlExpressionList arguments
}

override getter @gtlGetterCallExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  @gtlDataList dataArguments = .emptyList
  for () in arguments do
    dataArguments += ![expression eval !gtlVariableMap !lib]
  end
  @gtlData targetData = [target eval !gtlVariableMap !lib]
  result = [targetData performGetter !getterName !dataArguments !lib]
}


proc checkArgumentError
  ?let @lstring name
  ?let @type    formalType
  ?let @gtlData actualArgument
  ?let @uint    argumentNum
{
  if formalType != [actualArgument embeddedType] then
    let @type argType = [actualArgument dynamicType]
    log argType
    error name : [formalType typeName] + " expected for argument "
      + argumentNum + ", " + [[actualArgument dynamicType] typeName]
      + " provided"
  end
}

func validateReturnValue
  ?let @lstring functionName
  ?let @object  returnedValue
  ->@gtlData    result
{
  @type returnedType = [returnedValue objectDynamicType]
  @location loc = [functionName location]
  if    returnedType == `@bigint then
    result = @gtlInt.new    { !loc !returnedValue as @bigint }
  elsif returnedType == `@double then
    result = @gtlFloat.new  { !loc !returnedValue as @double }
  elsif returnedType == `@string then
    result = @gtlString.new { !loc !returnedValue as @string }
  elsif returnedType == `@bool   then
    result = @gtlBool.new   { !loc !returnedValue as @bool   }
  else
    error functionName
      : "this function does not return a compatible type" : result
  end
}

#-----------------------------------------------------------------------------*
# @gtlFunctionCallExpression : Does a function call
#-----------------------------------------------------------------------------*
class @gtlFunctionCallExpression : @gtlExpression {
  @lstring           functionName
  @gtlExpressionList functionArguments
}

override getter @gtlFunctionCallExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  if @function.isFunctionDefined { ![functionName string] } then

    @objectlist arguments = .emptyList
    @gtlDataList dataArguments = .emptyList

    for () in functionArguments do
      @gtlData arg = [expression eval !gtlVariableMap !lib]
      dataArguments += !arg
      [arg addMyValue !?arguments]
      #@arguments += ![arg object]
    end
    
    @function function = .functionWithName { ![functionName string] }

    let @typelist formalParameterList = [function formalParameterTypeList]
    if [formalParameterList length] != [arguments length] then
      error functionName: "this function is invoked with "
        + [arguments length] + " argument"
        + if [arguments length] > 1 then "s" else "" end
        + ", but requires " + [formalParameterList length] + " argument"
        + if [formalParameterList length] > 1 then "s" else "" end
        : result
    else
      for (formal) in formalParameterList, (actual) in dataArguments do (index)
        checkArgumentError(!functionName !formal !actual !index)
      end
      if @uint.errorCount == 0 then
        let @object returnedValue =
          [function invoke !arguments ![functionName location]]
        result = validateReturnValue(!functionName !returnedValue) 
      else
        result = @gtlUnconstructed.new { ![functionName location] }
      end
    end
  else
    @gtlFunction function = [lib getFunction !functionName]
    @gtlDataList arguments = .emptyList
    for () in functionArguments do
      arguments += ![expression eval !gtlVariableMap !lib]
    end
    result = [function call ![functionName location] !lib !arguments]
  end
}

#-----------------------------------------------------------------------------*
# @gtlExistsExpression : returns true if the variable exists false otherwise
#-----------------------------------------------------------------------------*
class @gtlExistsExpression : @gtlExpression {
  @gtlVarPath variable
}

override getter @gtlExistsExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  result = @gtlBool.new {
    !where ![variable exists !gtlVariableMap !lib]
  }
}

#-----------------------------------------------------------------------------*
# @gtlExistsDefaultExpression : returns the variable if it exists
#                               or a default value if it does not exist
#-----------------------------------------------------------------------------*
class @gtlExistsDefaultExpression : @gtlExistsExpression {
  @gtlExpression defaultValue
}

override getter @gtlExistsDefaultExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  if [variable exists !gtlVariableMap !lib] then
    result = [variable get !gtlVariableMap !lib]
  else
    result = [defaultValue eval !gtlVariableMap !lib]
  end
}

#-----------------------------------------------------------------------------*
# @gtlTypeOfExpression : the type of the variable
#-----------------------------------------------------------------------------*
class @gtlTypeOfExpression : @gtlExpression {
  @gtlVarPath variable
}

override getter @gtlTypeOfExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  @gtlData variableValue = [variable get !gtlVariableMap !lib]
  result = @gtlType.new { !where ![variableValue dynamicType] }
}

#-----------------------------------------------------------------------------*
# @gtlMapOfStructExpression : convert a struct to a map
#-----------------------------------------------------------------------------*
class @gtlMapOfStructExpression : @gtlExpression {
  @gtlExpression expression
}

override getter @gtlMapOfStructExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  @gtlData expressionValue = [expression eval !gtlVariableMap !lib]
  cast expressionValue
  case == @gtlStruct expressionValueStruct:
    result = @gtlMap.new { !where ![expressionValueStruct value] }
  else
    error where : "struct expected" : result
  end
}

#-----------------------------------------------------------------------------*
# @gtlMapOfListExpression : convert a list of structs to a map
#-----------------------------------------------------------------------------*
class @gtlMapOfListExpression : @gtlMapOfStructExpression {
  @lstring key
}

override getter @gtlMapOfListExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  @gtlData expressionValue = [expression eval !gtlVariableMap !lib]
  cast expressionValue
  case == @gtlList expressionValueList:
    @gtlVarMap resultMap = .emptyMap
    for (item) in [expressionValueList value] do (index)
      cast item
      case == @gtlStruct itemStruct:
        if [[itemStruct value] hasKey ![key string]] then
          [[itemStruct value] get !key ?@gtlData keyValue]
          [!?resultMap put
            ![keyValue lstring]
            !item
          ]
        else
          error [expressionValue where] : "item at index " + index
            + " does not have field named " + key
        end
      else
        error [expressionValue where] : "list of struct expected"
      end
    end
    result = @gtlMap.new { !where !resultMap }
  else
    error [expressionValue where] : "list expected" : result
  end
}

#-----------------------------------------------------------------------------*
# @gtlListOfExpression : convert a map to a list
#-----------------------------------------------------------------------------*
class @gtlListOfExpression : @gtlExpression {
  @gtlExpression expression
}

override getter @gtlListOfExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  @gtlData expressionValue = [expression eval !gtlVariableMap !lib]
  cast expressionValue
  case == @gtlMap expressionValueMap:
    @list resultList = .emptyList
    for (key item) in [expressionValueMap value] do
      resultList += !item
    end
    result = @gtlList.new { !where !resultList }
  else
    error where : "map expected" : result
  end
}

#-----------------------------------------------------------------------------*
# @gtlLiteralStructExpression
#-----------------------------------------------------------------------------*
class @gtlLiteralStructExpression : @gtlExpression {
  @gtlExpressionMap value
}

override getter @gtlLiteralStructExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  @gtlVarMap resultStruct = .emptyMap
  for (key item) in value do
    [!?resultStruct put !key ![item eval !gtlVariableMap !lib]]
  end
  result = @gtlStruct.new { !where !resultStruct }
}

#-----------------------------------------------------------------------------*
# @gtlLiteralMapExpression
#-----------------------------------------------------------------------------*
class @gtlLiteralMapExpression : @gtlExpression {
  @gtlExpressionMap value
}

override getter @gtlLiteralMapExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  @gtlVarMap resultStruct = .emptyMap
  for (key item) in value do
    [!?resultStruct put !key ![item eval !gtlVariableMap !lib]]
  end
  result = @gtlMap.new { !where !resultStruct }
}

#-----------------------------------------------------------------------------*
# @gtlLiteralListExpression
#-----------------------------------------------------------------------------*
class @gtlLiteralListExpression : @gtlExpression {
  @gtlExpressionList value
}

override getter @gtlLiteralListExpression eval
  ? let @gtlVarMap  gtlVariableMap
  ? let @library    lib
  -> @gtlData result
{
  @list resultList = .emptyList
  for (item) in value do
    resultList += ![item eval !gtlVariableMap !lib]
  end
  result = @gtlList.new { !where !resultList }
}


#-----------------------------------------------------------------------------*
#
#  @file gtl_instructions.galgas
#
#  @section desc File description
#
#  Instructions of GTL.
#
#  @section copyright Copyright
#
#  Goil OIL compiler, part of Trampoline RTOS
#
#  Trampoline is copyright (c) CNRS, University of Nantes,
#  Ecole Centrale de Nantes
#  Trampoline is protected by the French intellectual property law.
#
#  This software is distributed under the GNU Public Licence V2.
#  Check the LICENSE file in the root directory of Trampoline
#
#  $Date$
#  $Rev$
#  $Author$
#  $URL$
#
#-----------------------------------------------------------------------------*

#=============================================================================*
# abstract class for a template instruction
#-----------------------------------------------------------------------------*
abstract class @gtlInstruction {
  @location where
}

abstract method @gtlInstruction execute
  ? let @gtlContext context
  ?!@gtlVarMap      gtlVariableMap
  ? let @library    lib
  ?!@string         outputString

#=============================================================================*
# instruction list
#-----------------------------------------------------------------------------*
list @gtlInstructionList {
  @gtlInstruction instruction
}

method @gtlInstructionList execute
  ?let @gtlContext context
  ?!@gtlVarMap     gtlVariableMap
  ? let @library   lib
  ?!@string        outputString
{
  for () in self do
    [instruction execute !context !?gtlVariableMap !lib !?outputString]
  end
}

#-----------------------------------------------------------------------------*
# let unconstructed instruction
#-----------------------------------------------------------------------------*
class @gtlLetUnconstructedInstruction : @gtlInstruction {
  @gtlVarPath    lValue
}

override method @gtlLetUnconstructedInstruction execute
  ?let @gtlContext unused context
  ?!@gtlVarMap            gtlVariableMap
  ?let @library           lib
  ?!@string        unused outputString
{ 
  [lValue setMe !?gtlVariableMap !lib !@gtlUnconstructed.new { ![[lValue itemAtIndex !0] location] } ]
}
  
#-----------------------------------------------------------------------------*
# let instructions
#-----------------------------------------------------------------------------*
abstract class @gtlAssignInstruction : @gtlLetUnconstructedInstruction {
  @gtlExpression rValue
}

#-----------------------------------------------------------------------------*
# = assignment
#-----------------------------------------------------------------------------*
class @gtlLetInstruction           : @gtlAssignInstruction {}

override method @gtlLetInstruction execute
  ?let @gtlContext unused context
  ?!@gtlVarMap            gtlVariableMap
  ?let @library           lib
  ?!@string        unused outputString
{ 
  [lValue setMe !?gtlVariableMap !lib ![rValue eval !gtlVariableMap !lib]]
}
  
#-----------------------------------------------------------------------------*
# += assignment
#-----------------------------------------------------------------------------*
class @gtlLetAddInstruction        : @gtlAssignInstruction {}

override method @gtlLetAddInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{ 
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] addOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}
  
#-----------------------------------------------------------------------------*
# -= assignment
#-----------------------------------------------------------------------------*
class @gtlLetSubstractInstruction  : @gtlAssignInstruction {}

override method @gtlLetSubstractInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{ 
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] subOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}

#-----------------------------------------------------------------------------*
# *= assignment
#-----------------------------------------------------------------------------*
class @gtlLetMultiplyInstruction   : @gtlAssignInstruction {}   

override method @gtlLetMultiplyInstruction execute
  ? let@gtlContext unused context
  ?!@gtlVarMap            gtlVariableMap
  ? let @library          lib
  ?!@string        unused outputString
{ 
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] mulOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}

#-----------------------------------------------------------------------------*
# /= assignment
#-----------------------------------------------------------------------------*
class @gtlLetDivideInstruction     : @gtlAssignInstruction {}   

override method @gtlLetDivideInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{ 
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] divOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}

#-----------------------------------------------------------------------------*
# %= assignment
#-----------------------------------------------------------------------------*
class @gtlLetModuloInstruction     : @gtlAssignInstruction {}   

override method @gtlLetModuloInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{ 
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] divOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}

#-----------------------------------------------------------------------------*
# <<= assignment
#-----------------------------------------------------------------------------*
class @gtlLetShiftLeftInstruction  : @gtlAssignInstruction {}   

override method @gtlLetShiftLeftInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{ 
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] slOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}

#-----------------------------------------------------------------------------*
# >>= assignment
#-----------------------------------------------------------------------------*
class @gtlLetShiftRightInstruction : @gtlAssignInstruction {}   

override method @gtlLetShiftRightInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{ 
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] srOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}

#-----------------------------------------------------------------------------*
# &= assignment
#-----------------------------------------------------------------------------*
class @gtlLetAndInstruction        : @gtlAssignInstruction {}   

override method @gtlLetAndInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{ 
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] andOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}

#-----------------------------------------------------------------------------*
# |= assignment
#-----------------------------------------------------------------------------*
class @gtlLetOrInstruction         : @gtlAssignInstruction {}   

override method @gtlLetOrInstruction execute 
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{  
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] orOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}

#-----------------------------------------------------------------------------*
# ^= assignment
#-----------------------------------------------------------------------------*
class @gtlLetXorInstruction        : @gtlAssignInstruction {}   

override method @gtlLetXorInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{ 
  [lValue setMe
    !?gtlVariableMap
    !lib
    ![[lValue get  !gtlVariableMap !lib] xorOp
     ![rValue eval !gtlVariableMap !lib]]
  ]
}

#-----------------------------------------------------------------------------*
# %...% : template string instruction
#-----------------------------------------------------------------------------*
class @gtlTemplateStringInstruction : @gtlInstruction {
  @string value
}

override method @gtlTemplateStringInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap      unused gtlVariableMap
  ? let @library    unused lib
  ?!@string                outputString
{
  outputString += value
}

#-----------------------------------------------------------------------------*
# ! : emit instruction
#-----------------------------------------------------------------------------*
class @gtlEmitInstruction : @gtlInstruction {
  @gtlExpression rValue
}

override method @gtlEmitInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string                outputString
{ 
  outputString += [[rValue eval !gtlVariableMap !lib] string]
}

#-----------------------------------------------------------------------------*
# write to : write the result of instruction execution to a file
#-----------------------------------------------------------------------------*
class @gtlWriteToInstruction : @gtlInstruction {
  @gtlExpression      fileNameExpression
  @bool               isExecutable
  @gtlInstructionList instructions
}

override method @gtlWriteToInstruction execute
  ? let @gtlContext        context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{ 
  @string fullFileName = [[fileNameExpression eval !gtlVariableMap !lib] string]
  @gtlString fileName = .new{!where ![fullFileName lastPathComponent]}
  @gtlString filePath = .new{!where ![fullFileName nativePathWithUnixPath]}
  @string result = ""
  @gtlVarMap varsCopy = gtlVariableMap
  # remove the current FILENAME and FILEPATH variable
  # and replace them with 
  [!?varsCopy replaceOrCreateAtLevel
    !@lstring.new{!"FILENAME" !where}
    !fileName
    !0
  ]
  [!?varsCopy replaceOrCreateAtLevel
    !@lstring.new{!"FILEPATH" !where}
    !filePath
    !0
  ]
  if (@uint.errorCount == 0) then
    [instructions execute !context !?varsCopy !lib !?result]
    if (@uint.errorCount == 0) then
      if isExecutable then
        @string directory = [fullFileName stringByDeletingLastPathComponent]
        if directory != "" then [directory makeDirectory] end
        [result writeToExecutableFile !fullFileName]
      else
        [result makeDirectoryAndWriteToFile !fullFileName]
      end
    end
  end
}

#-----------------------------------------------------------------------------*
# template instructions : invoke a template
#-----------------------------------------------------------------------------*
class @gtlTemplateInstruction : @gtlInstruction {
  @lstring            prefix
  @gtlExpression      fileName
  @bool               ifExists
  @gtlInstructionList instructionsIfNotFound
}

override method @gtlTemplateInstruction execute
  ? let @gtlContext     context
  ?!@gtlVarMap          gtlVariableMap
  ? let @library        lib
  ?!@string    unused   outputString
{
  @gtlContext newContext = context
  if [prefix string] != "" then
    [!?newContext setPrefix ![prefix string]]
  end
  @lstring templateFileName =
    [[fileName eval !gtlVariableMap !lib] as @gtlString lstring]
#  gtlInvocation(
#    !templateFileName
#    !newContext
#    !ifExists == false
#    !false
#    !gtlVariableMap
#    !?outputString
#    ?let @bool found
#  )
#  if not found & ifExists then
#    @gtlVarMap localMap = .mapWithMapToOverride{!gtlVariableMap}
#    [instructionsIfNotFound execute !context !?localMap !funcs !?outputString]
#    gtlVariableMap = [localMap overriddenMap]
#  end
}

#-----------------------------------------------------------------------------*
# template instructions : set the destination variable with a number of spaces
# equals to the current column number in the output string
#-----------------------------------------------------------------------------*
class @gtlGetColumnInstruction : @gtlInstruction {
  @gtlVarPath    destVariable
}

override method @gtlGetColumnInstruction execute
  ? let @gtlContext     unused context
  ?!@gtlVarMap                 gtlVariableMap
  ? let @library               lib
  ?!@string                    outputString
{
  @string value = ""
  @bool searchEndOfLine = true
  @uint index = [outputString length]
  loop ([outputString length]) while (index > 0) & searchEndOfLine do
    searchEndOfLine = [outputString characterAtIndex !index - 1] != '\n'
    index--
    if searchEndOfLine then
      value += " "
    end
  end
  [destVariable setMe !?gtlVariableMap !lib !@gtlString.new{!where !value}]
}

#-----------------------------------------------------------------------------*
# template instructions : if statement
#-----------------------------------------------------------------------------*
list @gtlThenElsifStatementList
{
  @gtlExpression      condition
  @gtlInstructionList instructionList
}

class @gtlIfStatementInstruction : @gtlInstruction {
  @gtlThenElsifStatementList thenElsifList
  @gtlInstructionList        elseList
}

override method @gtlIfStatementInstruction execute
  ? let @gtlContext     context
  ?!@gtlVarMap          gtlVariableMap
  ? let @library        lib
  ?!@string             outputString
{
  @gtlVarMap localMap = .mapWithMapToOverride{!gtlVariableMap}
  
  @bool noConditionMatching = true
  for () in thenElsifList while noConditionMatching do
    @gtlData dataCondition = [condition eval !localMap !lib]
    if dataCondition is == @gtlBool then
      @bool boolCondition = [dataCondition as @gtlBool value]
      if boolCondition then
        [instructionList execute !context !?localMap !lib !?outputString]
        noConditionMatching = false
      end
    else
      error dataCondition : "bool expected" 
    end
  end
  if noConditionMatching then
    [elseList execute !context !?localMap !lib !?outputString]
  end

  gtlVariableMap = [localMap overriddenMap]
}

#-----------------------------------------------------------------------------*
# template instructions : foreach statement
#-----------------------------------------------------------------------------*
class @gtlForeachStatementInstruction : @gtlInstruction {
  @lstring            identifier
  @gtlExpression      iterable
  @gtlInstructionList beforeList
  @gtlInstructionList betweenList
  @gtlInstructionList afterList
  @gtlInstructionList doList
}

method @gtlForeachStatementInstruction iterateOnMap
  ? let @gtlContext     context
  ?!@gtlVarMap          variableMap
  ? let @library        lib
  ?!@string             outputString
  ? let @gtlMap         iterableMap
{
  @lstring keyName = .new{!"KEY" !where}
  @lstring indexName = .new{!"INDEX" !where}
  for () in [iterableMap value]
  before
    [beforeList execute !context !?variableMap !lib !?outputString]
  do (index)
    [!?variableMap replaceOrCreate !identifier !value]
    [!?variableMap replaceOrCreate
      !keyName !@gtlString.new{!where ![lkey string]}]
    [!?variableMap replaceOrCreate
      !indexName !@gtlInt.new{!where ![index bigint]}]
    [doList execute !context !?variableMap !lib !?outputString]
  between
    [betweenList execute !context !?variableMap !lib !?outputString]
  after
    [afterList execute !context !?variableMap !lib !?outputString]
  end
}

method @gtlForeachStatementInstruction iterateOnList
  ? let @gtlContext     context
  ?!@gtlVarMap          variableMap
  ? let @library        lib
  ?!@string             outputString
  ? let @gtlList        iterableList
{
  @lstring indexName = .new{!"INDEX" !where}
  for () in [iterableList value]
  before
    [beforeList execute !context !?variableMap !lib !?outputString]
  do (index)
    [!?variableMap replaceOrCreate !identifier !value]
    [!?variableMap replaceOrCreate
      !indexName !@gtlInt.new{!where ![index bigint]}]
    [doList execute !context !?variableMap !lib !?outputString]
  between
    [betweenList execute !context !?variableMap !lib !?outputString]
  after
    [afterList execute !context !?variableMap !lib !?outputString]
  end
}

override method @gtlForeachStatementInstruction execute
  ? let @gtlContext    context
  ?!@gtlVarMap         gtlVariableMap
  ? let @library       lib
  ?!@string            outputString
{
  @gtlVarMap localMap = .mapWithMapToOverride{!gtlVariableMap}
  @gtlData iterableData = [iterable eval !localMap !lib]
  cast iterableData
  case == @gtlMap iterableMap:
    [self iterateOnMap !context !?localMap !lib !?outputString !iterableMap]
  case == @gtlList iterableList:
    [self iterateOnList !context !?localMap !lib !?outputString !iterableList]
  else
    error [iterable location] : "Map or List expected"
  end 
  gtlVariableMap = [localMap overriddenMap]
}

#-----------------------------------------------------------------------------*
# template instructions : for statement
#-----------------------------------------------------------------------------*
class @gtlForStatementInstruction : @gtlInstruction {
  @lstring            identifier
  @gtlExpressionList  iterable
  @gtlInstructionList betweenList
  @gtlInstructionList doList
}

override method @gtlForStatementInstruction execute
  ? let @gtlContext     context
  ?!@gtlVarMap          gtlVariableMap
  ? let @library        lib
  ?!@string             outputString
{
  @lstring indexName = .new{!"INDEX" !where}
  @gtlVarMap localMap = .mapWithMapToOverride{!gtlVariableMap}
  for () in iterable
  do (index)
    @gtlData value = [expression eval !localMap !lib]
    [!?localMap replaceOrCreate !identifier !value]
    [!?localMap replaceOrCreate !indexName !@gtlInt.new{!where ![index bigint]}]
    [doList execute !context !?localMap !lib !?outputString]
  between
    [betweenList execute !context !?localMap !lib !?outputString]
  end
  gtlVariableMap = [localMap overriddenMap]
}

#-----------------------------------------------------------------------------*
# template instructions : loop statement
#-----------------------------------------------------------------------------*
class @gtlLoopStatementInstruction : @gtlInstruction {
  @lstring            identifier
  @gtlExpression      start
  @gtlExpression      stop
  @gtlExpression      step
  @sint64             upDown
  @gtlInstructionList beforeList
  @gtlInstructionList betweenList
  @gtlInstructionList afterList
  @gtlInstructionList doList
}

override method @gtlLoopStatementInstruction execute
  ? let @gtlContext     context
  ?!@gtlVarMap          gtlVariableMap
  ? let @library        lib
  ?!@string             outputString
{
  @gtlVarMap localMap = .mapWithMapToOverride{!gtlVariableMap}
  @gtlData startData = [start eval !localMap !lib]
  @gtlData stopData  = [stop  eval !localMap !lib]
  @gtlData stepData  = [step  eval !localMap !lib]
  @bigint startVal
  @bigint stopVal
  @bigint stepVal
  if startData is == @gtlInt then 
    startVal = [startData as @gtlInt value]
  else
    error [start location] : "int expected" : startVal
  end
  if stopData is == @gtlInt then
    stopVal  = [stopData  as @gtlInt value]
  else
    error [stop location] : "int expected" : stopVal
  end
  if stepData is == @gtlInt then
    stepVal  = [stepData  as @gtlInt value] * upDown
  else
    error [step location] : "int expected" : stepVal
  end
  @bigint direction = 1_G
  if stepVal < 0_G then direction = -1_G end
  if (stopVal - startVal) * direction >= 0_G then
    [beforeList execute !context !?localMap !lib !?outputString]
    @uint count = [(stopVal - startVal) * direction + 1LS uint]
    loop (count)
      [!?localMap replaceOrCreate
        !identifier !@gtlInt.new{![identifier location] !startVal}]
      [doList execute !context !?localMap !lib !?outputString]
      startVal = startVal + stepVal
    while (stopVal - startVal) * direction >= 0_G do
      [betweenList execute !context !?localMap !lib !?outputString]
    end
    [afterList execute !context !?localMap !lib !?outputString]
  end
  gtlVariableMap = [localMap overriddenMap]
}

#-----------------------------------------------------------------------------*
# template instructions : repeat statement
#-----------------------------------------------------------------------------*
class @gtlRepeatStatementInstruction : @gtlInstruction {
  @gtlExpression      condition
  @gtlInstructionList continueList
  @gtlInstructionList doList
}

override method @gtlRepeatStatementInstruction execute
  ? let @gtlContext     context
  ?!@gtlVarMap          gtlVariableMap
  ? let @library        lib
  ?!@string             outputString
{
  @gtlVarMap localMap = .mapWithMapToOverride{!gtlVariableMap}
  @bool boolCondition = false
  
  loop (@uint.max{})
    [continueList execute !context !?localMap !lib !?outputString]
    @gtlData conditionData = [condition eval !localMap !lib]
    if [conditionData dynamicType] == `@gtlBool then
      boolCondition = [conditionData as @gtlBool value] 
    else
      error conditionData : "bool expected"
    end
  while boolCondition do
    [doList execute !context !?localMap !lib !?outputString]
  end
  gtlVariableMap = [localMap overriddenMap]
}

#-----------------------------------------------------------------------------*
# template instructions : error statement
#-----------------------------------------------------------------------------*
class @gtlErrorStatementInstruction : @gtlInstruction {
  @gtlVarPath    identifier
  @bool          hereInstead
  @gtlExpression errorMessage
}

override method @gtlErrorStatementInstruction execute
  ? let@gtlContext  unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{
  @location errorLocation
  if hereInstead then 
    errorLocation = where
  else
    errorLocation = [[identifier get !gtlVariableMap !lib] where]
  end
  @gtlData errorMessageData = [errorMessage eval !gtlVariableMap !lib] 
  if [errorMessageData dynamicType] == `@gtlString then
    error errorLocation : [errorMessageData as @gtlString value]
  else
    error [errorMessage location] : "string expected"
  end
}

#-----------------------------------------------------------------------------*
# template instructions : warning statement
#-----------------------------------------------------------------------------*
class @gtlWarningStatementInstruction : @gtlInstruction {
  @gtlVarPath    identifier
  @bool          hereInstead
  @gtlExpression warningMessage
}

override method @gtlWarningStatementInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{
  @location warningLocation
  if hereInstead then 
    warningLocation = where
  else
    warningLocation = [[identifier get !gtlVariableMap !lib] where]
  end
  @gtlData warningMessageData = [warningMessage eval !gtlVariableMap !lib]
  if [warningMessageData dynamicType] == `@gtlString then
    error warningLocation : [warningMessageData as @gtlString value]
  else
    error [warningMessage location] : "string expected"
  end
}

#-----------------------------------------------------------------------------*
# template instructions : print statement
#-----------------------------------------------------------------------------*
class @gtlPrintStatementInstruction : @gtlInstruction {
  @bool          carriageReturn
  @gtlExpression messageToPrint
}

override method @gtlPrintStatementInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{
  @string messageToPrintString =
    [[messageToPrint eval !gtlVariableMap !lib] string]
  message messageToPrintString
  if carriageReturn then message "\n" end
}

#-----------------------------------------------------------------------------*
# template instructions : display statement
#-----------------------------------------------------------------------------*
class @gtlDisplayStatementInstruction : @gtlInstruction {
  @gtlVarPath variablePath
}

override method @gtlDisplayStatementInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{
  @gtlData variable = [variablePath get !gtlVariableMap !lib]
  message [variable desc !0]
}

#-----------------------------------------------------------------------------*
# template instructions : sort list of struct of list of scalars statement
#-----------------------------------------------------------------------------*
list @sortingKeyList {
  @lstring key
  @lsint   order
}

abstract class @gtlAbstractSortInstruction : @gtlInstruction {
  @gtlVarPath     variablePath
}

abstract getter @gtlAbstractSortInstruction compare
  ?let @gtlData    s1
  ?let @gtlData    s2
  ->@sint          result

method @gtlAbstractSortInstruction swap
  ?!@list    aList
  ?let @uint index1
  ?let @uint index2
{
  @gtlData temp = [aList valueAtIndex !index1]
  [!?aList setValueAtIndex ![aList valueAtIndex !index2] !index1]
  [!?aList setValueAtIndex !temp !index2]
}

method @gtlAbstractSortInstruction partition
  ?!@list    aList
  ?let @uint min
  ?let @uint max
  ?!@uint    pivotIndex
{
  @gtlData pivot = [aList valueAtIndex !pivotIndex]
  [self swap !?aList !pivotIndex !max]
  @uint storeIndex = min
  @uint i = min
  loop (max - min)
  while i < max do
    if [self compare ![aList valueAtIndex !i] !pivot] == -1s then
      [self swap !?aList !i !storeIndex]
      storeIndex++
    end
    i++
  end
  [self swap !?aList !storeIndex !max]
  pivotIndex = storeIndex
}

method @gtlAbstractSortInstruction sort
  ?!@list    aList
  ?let @uint min
  ?let @uint max
{
  if min < max then
    @uint pivotIndex = (max + min) / 2
    [self partition !?aList !min !max !?pivotIndex]
    [self sort !?aList !min !pivotIndex]
    [self sort !?aList !pivotIndex+1 !max]
  end
}

override method @gtlAbstractSortInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{
  @gtlData variable = [variablePath get !gtlVariableMap !lib]
  cast variable
  case == @gtlList variableList:
    @list listToSort = [variableList value]
    @uint length = [listToSort length]    
    if length > 0 then
      [self sort !?listToSort !0 !length-1]
    end
    [variablePath setMe
      !?gtlVariableMap
      !lib
      !@gtlList.new { !where !listToSort }
    ]
  else
    [variablePath last ?@gtlVarItem lastComponent]
    error [lastComponent field] : "list expected"
  end
}

#-----------------------------------------------------------------------------*
class @gtlSortStatementStructInstruction : @gtlAbstractSortInstruction {
  @sortingKeyList sortingKey
}

override getter @gtlSortStatementStructInstruction compare
  ?let @gtlData    s1
  ?let @gtlData    s2
  ->@sint          result
{
  result = [self compareElements !s1 !s2 !sortingKey]
}

getter @gtlSortStatementStructInstruction compareElements
  ?let @gtlData    s1
  ?let @gtlData    s2
  ?@sortingKeyList keyList
  ->@sint          result
{
  if [keyList length] > 0 then
    @gtlStruct s1Struct = s1 as @gtlStruct
      error [s1 location] : "struct expected" : s1Struct
    @gtlStruct s2Struct = s2 as @gtlStruct
      error [s2 location] : "struct expected" : s2Struct
    [!?keyList popFirst ?@lstring field ?@lsint order]
    [[s1Struct value] get !field ?@gtlData s1Field]
    [[s2Struct value] get !field ?@gtlData s2Field]
    if [s1Field ltOp !s2Field] then
      result = -1S * order
    else
      if [s1Field gtOp !s2Field] then
        result = 1S * order
      else
        result = [self compareElements !s1 !s2 !keyList]
      end
    end
  else
    result = 0S
  end
}

#-----------------------------------------------------------------------------*
class @gtlSortStatementInstruction : @gtlAbstractSortInstruction {
  @lsint order
}

override getter @gtlSortStatementInstruction compare
  ?let @gtlData    s1
  ?let @gtlData    s2
  ->@sint          result
{
  if [s1 ltOp !s2] then
    result = -1S * order
  else
    if [s1 gtOp !s2] then
      result = 1S * order
    else
      result = 0S
    end
  end
}

#-----------------------------------------------------------------------------*
# template instructions : tab
#-----------------------------------------------------------------------------*
class @gtlTabStatementInstruction : @gtlInstruction {
  @gtlExpression tabValue
}

override method @gtlTabStatementInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{
  @gtlData tabValueData = [tabValue eval !gtlVariableMap !lib]
  @gtlInt tabValueInt = tabValueData as @gtlInt
    error [tabValueData location] : "int expected" : tabValueInt
}

#-----------------------------------------------------------------------------*
# template instructions : variables
#-----------------------------------------------------------------------------*
class @gtlVariablesInstruction : @gtlInstruction {}

override method @gtlVariablesInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library    unused lib
  ?!@string         unused outputString
{
  @string delimitor = @string.stringWithSequenceOfCharacters{!'=' !79 } + "\n"
  @string varDelim  = @string.stringWithSequenceOfCharacters{!'-' !79 } + "\n"
  @string separator = @string.stringWithSequenceOfCharacters{!'=' !17 }
  message separator + " Variables "
        + separator + "= Displayed from "
        + separator + "\n"
  message [where locationString] + "\n"
  message delimitor
  for (name variable) in gtlVariableMap do
  message varDelim
  message [name string] + "\n"
  message varDelim
  message [variable desc !0]
  end
  message delimitor
}

#-----------------------------------------------------------------------------*
# template instructions : [target setter : <argument list>]
#-----------------------------------------------------------------------------*
class @gtlSetterCallInstruction : @gtlInstruction {
  @gtlVarPath        target
  @lstring           setterName
  @gtlExpressionList arguments
}

override method @gtlSetterCallInstruction execute
  ? let @gtlContext unused context
  ?!@gtlVarMap             gtlVariableMap
  ? let @library           lib
  ?!@string         unused outputString
{
  @gtlDataList dataArguments = .emptyList
  for () in arguments do
    dataArguments += ![expression eval !gtlVariableMap !lib]
  end
  @gtlData targetData = [target get !gtlVariableMap !lib]
  [!?targetData performSetter !setterName !dataArguments !lib]
  [target setMe !?gtlVariableMap !lib !targetData]
}

